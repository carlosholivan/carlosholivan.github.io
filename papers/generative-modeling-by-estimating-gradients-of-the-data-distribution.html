<!DOCTYPE HTML>
<html>
	<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Carlos Hern&aacute;ndez Oliv&aacute;n</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="" />
	<meta name="keywords" content="" />
	<meta name="author" content="" />

  <!-- Facebook and Twitter integration -->
	<meta property="og:title" content=""/>
	<meta property="og:image" content=""/>
	<meta property="og:url" content=""/>
	<meta property="og:site_name" content=""/>
	<meta property="og:description" content=""/>
	<meta name="twitter:title" content="" />
	<meta name="twitter:image" content="" />
	<meta name="twitter:url" content="" />
	<meta name="twitter:card" content="" />

	<!-- Place favicon.ico and apple-touch-icon.png in the root directory -->
	<link rel="shortcut icon" href="favicon.ico">

	<link href="https://fonts.googleapis.com/css?family=Karla:400,700" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Playfair+Display:400,400i,700" rel="stylesheet">
	
	<!-- Animate.css -->
	<link rel="stylesheet" href="../css/animate.css">
	<!-- Icomoon Icon Fonts-->
	<link rel="stylesheet" href="../css/icomoon.css">
	<!-- Bootstrap  -->
	<link rel="stylesheet" href="../css/bootstrap.css">
	<!-- Owl Carousel -->
	<link rel="stylesheet" href="../css/owl.carousel.min.css">
	<link rel="stylesheet" href="../css/owl.theme.default.min.css">
	<!-- Magnific Popup -->
	<link rel="stylesheet" href="../css/magnific-popup.css">

	<link rel="stylesheet" href="../css/style.css">
    <link rel="stylesheet" href="../css/paper-algorithms.css">


	<!-- Modernizr JS -->
	<script src="js/modernizr-2.6.2.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
	<!-- FOR IE9 below -->
	<!--[if lt IE 9]>
	<script src="js/respond.min.js"></script>
	<![endif]-->

    

	</head>
	<body>

	<!-- Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-3CDKKZRCVT"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());
		gtag('config', 'G-3CDKKZRCVT');
	</script>

	<nav id="colorlib-main-nav" role="navigation">
		<a href="#" class="js-colorlib-nav-toggle colorlib-nav-toggle active"><i></i></a>
		<div class="js-fullheight colorlib-table">
			<div class="colorlib-table-cell js-fullheight">
				<div class="row">
					<div class="col-md-12">
						<div class="form-group">
							<input type="text" class="form-control" id="search" placeholder="Enter any key to search...">
							<button type="submit" class="btn btn-primary"><i class="icon-search3"></i></button>
						</div>
					</div>
				</div>
				<div class="row">
					<div class="col-md-12">
						<ul>
							<li><a href="../index.html">Home</a></li>
							<li><a href="../curriculum.html">CV</a></li>
							<li><a href="../publications.html">Publications</a></li>
							<li><a href="../talks.html">Talks</a></li>
							<li class="active"><a href="../teaching.html">Teaching</a></li>
							<li><a href="../community-service.html">Community Service</a></li>
							<li><a href="../blog.html">Blog</a></li>
							<li><a href="../others.html">Others</a></li>
							<li><a href="../about.html">About</a></li>
							<li><a href="../contact.html">Contact</a></li>
						</ul>
					</div>
				</div>
			</div>
		</div>
	</nav>
	
	<div id="colorlib-page">
		<header>
			<div class="container">
				<div class="row">
					<div class="col-md-12">
						<div class="colorlib-navbar-brand">
							<a class="colorlib-logo" href="../index.html"><span>Ch</span><span>o</span></a>
						</div>
						<a href="#" class="js-colorlib-nav-toggle colorlib-nav-toggle"><i></i></a>
					</div>
				</div>
			</div>
		</header>

        <div id="colorlib-blog">
            <div class="container">
                <div class="row text-center">
                    <h2 class="bold">Paper Title</h2>
                </div>
                <div class="row">
                    <div class="col-md-12">
                        <div class="blog-entry">
                            <div class="desc">
                                <h1 class="text-center"><strong>Generative modeling by estimating gradients of the data distribution</strong></h1>
                                <h3 class="text-center">Yang Song and Stefano Ermon</h3>
                                <h4 class="text-center">In <em>Advances in Neural Information Processing Systems (NeurIPS)</em>, 2019</h4>
                                <p class="text-center">score-based models, diffusion models</p>
                            
                                <!--Bibtex citation-->
                                <style>
                                    body {
                                        margin: 0 auto; /* Remove default margin */
                                        background-color: #f0f0f0; /* Optional background color */
                                    }
                                    .bibtex-box {
                                        border: 1px solid #ccc;
                                        border-radius: 5px;
                                        padding: 5px; /* Reduced padding */
                                        margin: 20px auto; /* Center horizontally and add vertical margins */
                                        font-family: monospace;
                                        background-color: #f9f9f9;
                                        max-width: 600px; /* Set a maximum width */
                                        max-height: auto;
                                        text-align: left; /* Align text to the left */
                                    }
                                    .title {
                                        margin-bottom: 5px; /* 5px padding below the title */
                                    }
                                </style>
                                <div class="bibtex-box">
                                    <span style="font-size: smaller;" class="title">@article{song2019generative,</span><br>
                                    <span style="padding-left: 20px;font-size: smaller;">title={Generative modeling by estimating gradients of the data distribution},</span><br>
                                    <span style="padding-left: 20px;font-size: smaller;">author={Song, Yang and Ermon, Stefano},</span><br>
                                    <span style="padding-left: 20px;font-size: smaller;">journal={Advances in neural information processing systems},</span><br>
                                    <span style="padding-left: 20px;font-size: smaller;">year={2019},</span><br>
                                    <span style="padding-left: 20px;font-size: smaller;">volume={32},</span><br>
                                    <span>}</span>
                                </div>
                                <div class="text-center">
                                    <a href="" class="btn btn-primary btn-outline">PDF</a>
                                    <a href="" class="btn btn-primary btn-outline"><i class="icon-github"></i> Code</a>
                                    <a href="" class="btn btn-primary btn-outline">Blog</a>
                                </div>
                                <div style="padding-left: 20px;">
                                    <p>TL;DR: This work establishes score-based generative modeling by connecting score matching with generative modeling across multiple noise levels. It learns the score of the log data density through a score model and leverages Langevin dynamics with annealing for high-quality sampling.</p>
                                </div>
                            </div>
                            <div class="row" style="padding-left: 20px;">
                                <div class="col-md-12">
                                    <div class="article animate-box">
                                        <h2 id="table-of-contents">
                                            Table of Contents
                                        </h2>
                                        <h4 style="padding-left: 20px;">
                                            <a href="#introduction" style="text-decoration: none; color: inherit;">1. Introduction</a>
                                        </h4>
                                        <h4 style="padding-left: 20px;">
                                            <a href="#langevin-dynamics" style="text-decoration: none; color: inherit;">2. Score Matching and Langevin Dynamics</a>
                                        </h4>
                                        
                                    </div>
                                </div>
                            </div>
                            <div class="row">
                                <div class="col-md-12">
                                    <div class="article animate-box">
                                        <h2 id="introduction">
                                            <a href="#table-of-contents" style="text-decoration: none; color: inherit;">1. Introduction</a>
                                        </h2>
                                        <p>
                                            This paper introduces the following concepts:
                                            <ul>
                                                <li>
                                                    <strong>Score-based generative modeling</strong>. It introduces a new generative approach by learning the score function \( \nabla_\mathbf{x} \log p(\mathbf{x}) \) of the data distribution at multiple noise levels.
                                                    The new approach is called <i>score-based generative modeling</i> and it is based on the idea of estimating the gradient of the data distribution (log density) instead of learning directly the data distribution itself.
                                                    This simplifies the learning process.
                                                </li>
                                                <li>
                                                    <strong>Multi-level noise conditioning</strong>. Inspired by annealing processes, this work poposes to condiiton the score model on different noise scales.
                                                    This allows to capture low data density regions and improve the quality of the samples.
                                                </li>
                                                <li>
                                                    <strong>Connect score matching with generative modeling</strong>. This work leverages denoising score matching <a>[Vincent 2011]</a> by training a score network which predicts gradients of noised data densities. By iterative refinement, the model can producce high-quality samples.
                                                    This is connected with the points above and, in addition to them, establishes the so-called <i>score-based generative modeling</i>.
                                                </li>
                                                <li>
                                                    <strong>Annealed Langevin dynamics for sampling</strong>. Sampling is achieved using Langevin dynamics where noise levels are gradually reduced or annealed to guide the samples from initial random noise toward the data distribution.
                                                    This process is called <i>annealed Langevin dynamics</i> and addresses the slow mixing issues in high-dimensional sampling.
                                                </li>
                                                Note: Take into ccount that this paper likely established score-based generative modeling while Denoising Diffusion Probabilistic Models (DDPM) <a>[Ho et al. 2020]</a>. While this paper proposes advances in pure score-based models, DDPM connect score-based models and diffusion processes (that is, the forward and backward learning processes) and therefore, defined the well-known <i>diffusion models</i>.
                                            </ul>    
                                        </p>
                                    </div>
                                </div>
                            </div>
                            <div class="row">
                                <div class="col-md-12">
                                    <div class="article animate-box">
                                        <h2 id="langevin-dynamics">
                                            <a href="#table-of-contents" style="text-decoration: none; color: inherit;">2. Score Matching and Langevin Dynamics</a>
                                        </h2>
                                        <p>
                                            The basic idea behind the so-called <i>score-based generative modeling</i>, also known as <i>diffusion models</i>, is to train a score network such that \( s_\theta(\mathbf{x}) \approx \nabla_x \log p_{data}(\mathbf{x}) \) and then approximately obtain
                                            samples with Langevin dynamics using the score network \( s_\theta(\mathbf{x}) \). For that, we need to estimate the gradient of the data distribution with score matching.
                                            Therefore, we will introduce Langevin dynamics in this section, and then review score matching approaches.
                                        </p>
                                        <h3>2.1 Score Matching</h3>
                                        <p>
                                            Given a large dataset, we can use principle statistical methods like score matching to train a score model to estimate the underlying score function.
                                            In order to build a genertative model, we have to find a certain approach to create new datapoints from the given vector field of score functions.
                                            <div style="text-align: center; margin: 0; padding: 0; margin-top: 10px; margin-bottom: 10px;">
                                                <img src="generative-modeling-by-estimating-gradients-of-the-data-distribution/score-matching-intro.png" 
                                                     alt="Score Matching Intro" 
                                                     style="width: 70%; height: auto; display: block; margin: 0 auto; padding: 0;">
                                                <p style="font-size: small; margin: 0; padding: 0;">Fig. 1. Generative modeling approach.</p>
                                            </div>
                                            But, how can we do this?
                                            <br>
                                            Suppose we are given the score function \( s_\theta(\mathbf{x}) \) <a>(Fig. 1, left)</a> and imagine that there are many random points scattered accross it <a>(Fig. 1, middle)</a>.
                                            Can we move those data points to form samples from the score function? One idea is that we can potentially move those points by following the directions predicted by the score function. However this will not give us valid samples because all of those points will eventually collapse into each other <a>(Fig. 1, right)</a>.
                                            <br>
                                            This problem can be addressed by following a noise inversion of the score function. Equivalently, we inject gaussian noise to our score function and follow those noise perturbed score functions <a>(Fig. 1, right)</a>. If we keep this sampling procedure long enough to reach convergence, and if we set the step size to be very very small, then this method will give us the correct samples from the score function.
                                            This method is the well-known approach of Langevin dynamics [Parisi 1981], [Grenander and Miller 1994].
                                            Before dive in the Langevin dynamics, we will review the score matching approach.
                                            <br>

                                        </p>
                                        <h3>2.2 Langevin Dynamics</h3>
                                        <p>
                                            Langevin dynamics describes a type of stochastic differential equation (SDE) commonly used to model the evolution of systems subject to both deterministic forces and random fluctuations (noise). 
                                            In its most basic form, Langevin dynamics for a particle can be written as:
                                            \[
                                                \frac{d\mathbf{x}}{dt} = \underbrace{-\nabla U(\mathbf{x})}_{\text{Deterministic}} + \underbrace{\gamma \mathbf{z}(t)}_{\text{Stochastic}},
                                                \tag{Eq. 1} \label{eq:langevin-dynamics}
                                            \]
                                            where:
                                            <ul>
                                                <li> \( \mathbf{x} \) is the position of the particle.</li>
                                                <li> \( U(\mathbf{x}) \) is the potential energy function.</li>
                                                <li> \( \gamma \) is the noise strength coefficient.</li>
                                                <li> \( \mathbf{z}(t) \) is the stochastic term, often Gaussian nosise.</li>
                                            </ul>
                                            <a>Eq. 1</a> consists of 2 terms: the first term is the deterministic force, which is the gradient of the potential energy function \( U(\mathbf{x}) \), and the second term is the stochastic force, which is the noise term \( \gamma \mathbf{z}(t) \).
                                        </p>
                                        <h4>2.1.1. Discretized Langevin Dynamics</h4>
                                        <p>
                                            The discretized version of Langevin dynamics, which is a variation of Euler-Maruyama method, is given by:
                                            \[
                                                \mathbf{x}_{t} = \mathbf{x}_{t-1} + \frac{\epsilon}{2} \nabla_\mathbf{x} U(\mathbf{x}_t) + \sqrt{\epsilon} \, \mathbf{z}_t,
                                                \tag{Eq. 2} \label{eq:discretized-langevin-dynamics}
                                            \]
                                            where:
                                            <ul>
                                                <li> \( \epsilon > 0 \) is the step size.</li>
                                                <li> \( \mathbf{z}_t \) is the noise term, often Gaussian noise.</li>
                                                <li> \( \mathbf{x}_0 \sim \pi(\mathbf{x}) \) is the initial value with \pi being a prior distribution.</li>
                                                <li> \( \mathbf{z}_t \sim \mathcal{N}(0,I) \).</li>
                                            </ul>
                                            <a>Eq. 2</a> is the discretized version of <a>Eq. 1</a>, where the deterministic force is approximated by the gradient of the potential energy function \( U(\mathbf{x}_t) \) and the stochastic force is approximated by the noise term \( \sqrt{\epsilon} \, \mathbf{z}_t \).
                                            In the case of score-based modeling, the energy function term \( U(\mathbf{x}) \) is the score function \( \log p(\mathbf{\tilde{x}}_{t-1}) \). We will denote \( \mathbf{\tilde{x}} \) as the sample obtained by Langevin dynamics:
                                            \[
                                                \mathbf{\tilde{x}}_{t} = \mathbf{\tilde{x}}_{t-1} + \frac{\epsilon}{2} \nabla_\mathbf{x}  \log p(\mathbf{\tilde{x}}_{t-1}) + \sqrt{\epsilon} \, \mathbf{z}_t,
                                                \tag{Eq. 2} \label{eq:discretized-langevin-dynamics-score}
                                            \]
                                            When \( \epsilon \rightarrow 0\) and \( T \rightarrow \infty \), the distribution of \( \mathbf{\tilde{x}}_T \) becomes \( p(\mathbf{x}) \). When \( \epsilon > 0 \) and \( T < \infty \), a Metropolis-Hastings update is needed to correct the discretization error, but it can be ignored in practice.
                                            The discretization error comes from the discretization, where we choose \( \epsilon \) and \( T \) to be small enough to satisfy \( \mathbf{\tilde{x}}_T \approx p(\mathbf{x}) \).
                                            <br>
                                            Notice that with this formulation, we can train our score network such that \( s_\theta(\mathbf{x}) \approx \nabla_\mathbf{x} \log p_{data} \) and then obtain approximate samples from \( p_{data} \) through Langevin dynamics using the score network \( s_\theta(\mathbf{x}) \).
                                        </p>
                                        <h4>2.1.2. Annealed Langevin Dynamics</h4>
                                        <p></p>
                                        <div style="text-align: center; margin: 0; padding: 0; margin-top: 10px; margin-bottom: 10px;">
                                            <img src="generative-modeling-by-estimating-gradients-of-the-data-distribution/langevin-dynamics-score-matching.png" 
                                                 alt="Score Matching Intro" 
                                                 style="width: 70%; height: auto; display: block; margin: 0 auto; padding: 0;">
                                            <p style="font-size: small; margin: 0; padding: 0;">Fig. 2. Langevin dynamics for score-matching.</p>
                                        </div>
                                
                                        <h4>2.1.3. Sampling Langevin Dynamics</h4>
                                        <p>

                                        </p>
                                        <div class="algorithm-box" style="margin-bottom: 40px;">
                                            <div class="algorithm-title">Algorithm 1: Annealed Langevin dynamics.</div>
                                            <hr style="border: 1px solid black; width: 100%; margin: 5px 0;">

                                            <div class="algorithm-require"><strong>Require:</strong> \( \{ \sigma_i \}_{i=1}^{L}, \, \epsilon, \, T \).</div>
                                            <div class="algorithm-step">1: Initialize \( \tilde{\mathbf{x}}_0 \)</div>
                                            
                                            <div class="algorithm-step">2: <strong>for</strong> \( i \leftarrow 1 \) to \( L \) <strong>do</strong></div>
                                            
                                            <div class="algorithm-step">
                                                3:
                                                <span class="algorithm-inner-step">\( \alpha_i \leftarrow \epsilon \cdot \sigma_i^2 / \sigma_L^2 \)</span> <span>â–· \( \alpha_i \) is the step size.</span>
                                            </div>
                                            
                                            <div class="algorithm-step">
                                                4:
                                                <span class="algorithm-inner-step"><strong>for</strong> \( t \leftarrow 1 \) to \( T \) <strong>do</strong></span>
                                            </div>
                                            <div class="algorithm-inner-step">
                                                5:
                                                <span class="algorithm-inner-step">&nbsp;&nbsp; Draw \( \mathbf{z}_t \sim \mathcal{N}(0, \mathbf{I}) \)</span>                                            
                                                <br>
                                                6:
                                                <span class="algorithm-inner-step">&nbsp;&nbsp; \( \tilde{\mathbf{x}}_t \leftarrow \tilde{\mathbf{x}}_{t-1} + \frac{\alpha_i}{2} s_\theta(\tilde{\mathbf{x}}_{t-1}, \sigma_i) + \sqrt{\alpha_i} \, \mathbf{z}_t \)</span>
                                                <br>
                                                7:
                                                <span class="algorithm-inner-step"><strong></span>end for</strong>
                                            </div>
                                            <div class="algorithm-step">8: \( \tilde{\mathbf{x}}_0 \leftarrow \tilde{\mathbf{x}}_T \)</div>
                                            
                                            <div class="algorithm-step">9: <strong>end for</strong></div>
                                            <div class="algorithm-step"><strong>return</strong> \( \tilde{\mathbf{x}}_T \)</div>                                        
                                        </div>
                                        <h3>2.3. Score Matching + Langevin Dynamics</h3>
                                        <p>
                                            Combining score matching and Langevin dynamics naively does not produce good empirical results. There are several challenges that should be addressed to make this combination work.
                                            For example, <strong>it is hard to estimate score functions accurately in low data density regions.</strong>
                                            <br>
                                            Consider the density function <a>(Fig. 3, left)</a>, the ground truth score function <a>(Fig. 3, middle)</a> and the estimated score function <a>(Fig. 3, right)</a>.
                                            If we compare the estimated and ground truth scores, we can observe how accurate are they in high density regions (green boxes).
                                            But for low data density regions, the estimated scores are not accurate at all.
                                            <div style="text-align: center; margin: 0; padding: 0; margin-top: 10px; margin-bottom: 10px;">
                                                <img src="generative-modeling-by-estimating-gradients-of-the-data-distribution/density-regions-scores.png" 
                                                     alt="Score Matching Intro" 
                                                     style="width: 70%; height: auto; display: block; margin: 0 auto; padding: 0;">
                                                <p style="font-size: small; margin: 0; padding: 0;">Fig. 3. Density regions scores.</p>
                                            </div>
                                            This is not really unexpected because we use score matching to train our score model, and score matching compared the difference between the ground truth and the model only at samples from the data distribution.
                                            So, in low data densite regions we do not have enough samples and therefore, we do not have enough information to infer the true score functions in those regions. This is a huge obstacle for Langevin dynamics to provide high quality samples because Langevin dynamics will have a lot of trouble exploring and navigating those low data density regions.
                                            <br>
                                            How to address this challenge?
                                            <br>
                                            One idea is to inject Gaussian noise to perturb our data points. After adding enough Gaussian noise, we would perturb the data points to everywhere in the space. This means the size of low data density regions becomes smaller. In the image domain, this means adding Gaussian noise to perturb each pixel of the image. We can see in <a>Fig. 4</a> how the estimated score now become accurate almost everywhere.
                                            <div style="text-align: center; margin: 0; padding: 0; margin-top: 10px; margin-bottom: 10px;">
                                                <img src="generative-modeling-by-estimating-gradients-of-the-data-distribution/density-regions-scores-accurate.png" 
                                                     alt="Score Matching Intro" 
                                                     style="width: 70%; height: auto; display: block; margin: 0 auto; padding: 0;">
                                                <p style="font-size: small; margin: 0; padding: 0;">Fig. 4. Density regions scores after perturbation of data points.</p>
                                            </div>
                                            This phenomenom is very promising because it at least says that the score function of noisy data densities are much easier to be estimated accurately, and those score functions of oisy densities could provide valuable directional information to guide Langevin dynamics to move from low data density regions to high data density regions.
                                            However, simply injecting Gaussian noise does not solve all the problems, because the perturbation of data points distances are no longer good approximations to the original true data density.
                                            To solve this problem, this paper proposes using multiple sequence of different noise levels. In <a>Fig. 4</a>, 3 noise levels from \( \sigma_1 \) to \( \sigma_3 \). It uses Gaussian noise with mean 0 and standard deviation from \( \sigma_1 \) to \( \sigma_3 \) to perturb the training dataset.
                                            This will give use three noisy training datasets. For each noisy dataset, there will be a corresponding noisy data density, which is denoted as \( p_{\sigma_1}(\mathbf{x}) \) to \( p_{\sigma_3}(\mathbf{x}) \).
                                            We can show this behaviour in <a>Fig. 5</a>.
                                            <div style="text-align: center; margin: 0; padding: 0; margin-top: 10px; margin-bottom: 10px;">
                                                <img src="generative-modeling-by-estimating-gradients-of-the-data-distribution/density-regions-across-noise-levels.png" 
                                                     alt="Score Matching Intro" 
                                                     style="width: 70%; height: auto; display: block; margin: 0 auto; padding: 0;">
                                                <p style="font-size: small; margin: 0; padding: 0;">Fig. 5. Density regions across different noise levels.</p>
                                            </div>
                                            In the context of images, perturbation means using multiple levels of noise wihich will give us a sequence of images like:
                                            <div style="text-align: center; margin: 0; padding: 0; margin-top: 10px; margin-bottom: 10px;">
                                                <img src="generative-modeling-by-estimating-gradients-of-the-data-distribution/image-perturbation.png" 
                                                     alt="Score Matching Intro" 
                                                     style="width: 70%; height: auto; display: block; margin: 0 auto; padding: 0;">
                                                <p style="font-size: small; margin: 0; padding: 0;">Fig. 6. Image perturbation with different noise levels.</p>
                                            </div>
                                            After obtaining those noisy datasets, we would like to estimate the underlying density, the underlying score function of the corresponding noisy data densities.
                                            <br>
                                            But, how can we estimate three noisy score functions?
                                            <br>
                                            The most naive approach is to train three neural networks so each network will estimate the score function of a single noise level. This is not a scalable solution because in practice, we might require much more noise levels.
                                            Another approach is to consider a noise conditional score model. A noise conditional score model is a simple modification of our score model which takes the noise level $\sigma$ as one additional input dimension.
                                            The output corresponds to the score function of the data density perturbed with noise level \( \sigma \).
                                            <div style="text-align: center; margin: 0; padding: 0; margin-top: 10px; margin-bottom: 10px;">
                                                <img src="generative-modeling-by-estimating-gradients-of-the-data-distribution/noise-conditional-score-model.png" 
                                                     alt="Score Matching Intro" 
                                                     style="width: 20%; height: 20%; display: block; margin: 0 auto; padding: 0;">
                                                <p style="font-size: small; margin: 0; padding: 0;">Fig. 7. Noise conditional score model.</p>
                                            </div>    
                                            <br>
                                            So, how can we train this noise conditional score model?
                                            <br>
                                            We can leverage the idea of score matching. The score matching objective needs to be modified to jointly train the score model across all levels. In such modification, we have a summation with score matching losses.
                                            We have one socre matching loss for each noise level \( \sigma_i \) and a positive weighting function \( \lambda(\sigma_i) \). 
                                            The loss is a generalization to the training objective of the first version of diffusion probabilistic models <a>[Sohl-Dickstein et al. 2015]</a>.
                                            It connects score-based models with diffusion models was first unveiled by the Denoising Diffusion Probabilistic Models (DDPM) <a>[Ho et al. 2020]</a>.
                                            The score matching loss floows the expression:
                                            \[
                                                \frac{1}{N} \sum_{i=1}^{N} \underbrace{\lambda(\sigma_i)}_{\text{Positive weighting function}} \underbrace{\mathbb{E}_{p_{\sigma_i}(\mathbf{x})} \left[ \left\| \nabla_{\mathbf{x}} \log p_{\sigma_i}(\mathbf{x}) - s_{\theta}(\mathbf{x}, \sigma_i) \right\|_2^2 \right]}_{\text{Score matching loss}},
                                                \tag{Eq. 3} \label{eq:score-matching-loss}
                                            \]
                                            The weighting function \( \lambda \) balances the scales of score matching loss across all noise levels, which is helpful for optimizaion. The value of the weighting function is typically chosen using people's heuristics but it can also be derive using principled analysis of the problem. 
                                            By minimizing this modified score matching loss, if out optimizer is powerful enough, and our model expressive enough, then we will obtain an accurate score estimation for all noise labels.
                                            <br>
                                            After training this noise-conditional score model, how can we generate samples?
                                            <br>
                                            We can use Langevin dynamics. First, we can use Langevin dynamics to sample from the score model with the biggest perturbation of noise. the samples will be used as the initialization to sample from the score model fo the next noise level. We continue doing this process untill finally generate samples from the score function with the smallest noise level. This procedure is called **Annealed Langevin dynamics** because the rough intuition is hoping to gradually anneal down the temperature of our data density to gradually reduce the noise level.
                                            We can start from random noise, then modify the data according to the score model and the output will be accurate. This method outperform GANS (the best performing method for sample generation to that date) in inception score, but it does not in FID.
                                        </div>
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    


        <div class="row">
            <div class="col-md-12 text-center">
                <p>
                    &copy;
Copyright &copy;<script>document.write(new Date().getFullYear());</script> All rights reserved | Carlos Hern&aacute;ndez Oliv&aacute;n | <a href="https://colorlib.com" target="_blank">Colorlib</a>
                </p>
            </div>
        </div>
    </div>
</div>
</footer>

</div>

<!-- jQuery -->
<script src="../js/jquery.min.js"></script>
<!-- jQuery Easing -->
<script src="../js/jquery.easing.1.3.js"></script>
<!-- Bootstrap -->
<script src="../js/bootstrap.min.js"></script>
<!-- Waypoints -->
<script src="../js/jquery.waypoints.min.js"></script>
<!-- Owl Carousel -->
<script src="../js/owl.carousel.min.js"></script>
<!-- Magnific Popup -->
<script src="../js/jquery.magnific-popup.min.js"></script>
<script src="../js/magnific-popup-options.js"></script>

<!-- Main JS (Do not remove) -->
<script src="../js/main.js"></script>

</body>
</html>